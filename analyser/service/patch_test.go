package service_test

import (
	"fmt"
	"testing"

	"edu.buaa.soft/CVEGetter/analyser/service"
)

func TestHandlePatch(t *testing.T) {
	b := []byte("@@ -15,48 +15,34 @@ import (\n \t\"strings\"\n \t\"syscall\"\n \n-\t\"github.com/sylabs/singularity/internal/pkg/sylog\"\n-\n-\tspecs \"github.com/opencontainers/runtime-spec/specs-go\"\n-\n \t\"github.com/sylabs/singularity/internal/pkg/util/user\"\n-\t\"github.com/sylabs/singularity/pkg/util/fs/proc\"\n )\n \n const (\n \t// OciSubDir represents directory where OCI instance files are stored\n \tOciSubDir = \"oci\"\n \t// SingSubDir represents directory where Singularity instance files are stored\n \tSingSubDir = \"sing\"\n+\t// LogSubDir represents directory where Singularity instance log files are stored\n+\tLogSubDir = \"logs\"\n )\n \n const (\n-\tprivPath        = \"/var/run/singularity/instances\"\n-\tunprivPath      = \".singularity/instances\"\n+\tinstancePath    = \".singularity/instances\"\n \tauthorizedChars = `^[a-zA-Z0-9._-]+$`\n \tprognameFormat  = \"Singularity instance: %s [%s]\"\n )\n \n-var nsMap = map[specs.LinuxNamespaceType]string{\n-\tspecs.PIDNamespace:     \"pid\",\n-\tspecs.UTSNamespace:     \"uts\",\n-\tspecs.IPCNamespace:     \"ipc\",\n-\tspecs.MountNamespace:   \"mnt\",\n-\tspecs.CgroupNamespace:  \"cgroup\",\n-\tspecs.NetworkNamespace: \"net\",\n-\tspecs.UserNamespace:    \"user\",\n-}\n-\n // File represents an instance file storing instance information\n type File struct {\n-\tPath       string `json:\"-\"`\n-\tPid        int    `json:\"pid\"`\n-\tPPid       int    `json:\"ppid\"`\n-\tName       string `json:\"name\"`\n-\tUser       string `json:\"user\"`\n-\tImage      string `json:\"image\"`\n-\tPrivileged bool   `json:\"privileged\"`\n-\tConfig     []byte `json:\"config\"`\n+\tPath   string `json:\"-\"`\n+\tPid    int    `json:\"pid\"`\n+\tPPid   int    `json:\"ppid\"`\n+\tName   string `json:\"name\"`\n+\tUser   string `json:\"user\"`\n+\tImage  string `json:\"image\"`\n+\tConfig []byte `json:\"config\"`\n+\tUserNs bool   `json:\"userns\"`\n }\n \n // ProcName returns processus name based on instance name\n@@ -86,7 +72,7 @@ func CheckName(name string) error {\n }\n \n // getPath returns the path where searching for instance files\n-func getPath(privileged bool, username string, subDir string) (string, error) {\n+func getPath(username string, subDir string) (string, error) {\n \tpath := \"\"\n \tvar pw *user.User\n \tvar err error\n@@ -101,52 +87,27 @@ func getPath(privileged bool, username string, subDir string) (string, error) {\n \t\t}\n \t}\n \n-\tif privileged {\n-\t\tpath = filepath.Join(privPath, subDir, pw.Name)\n-\t\treturn path, nil\n-\t}\n-\n-\tcontainerID, hostID, err := proc.ReadIDMap(\"/proc/self/uid_map\")\n-\tif err != nil {\n-\t\treturn path, err\n-\t} else if containerID == 0 && containerID != hostID {\n-\t\tif pw, err = user.GetPwUID(hostID); err != nil {\n-\t\t\treturn path, err\n-\t\t}\n-\t}\n-\n \thostname, err := os.Hostname()\n \tif err != nil {\n \t\treturn path, err\n \t}\n \n-\tpath = filepath.Join(pw.Dir, unprivPath, subDir, hostname, pw.Name)\n+\tpath = filepath.Join(pw.Dir, instancePath, subDir, hostname, pw.Name)\n \treturn path, nil\n }\n \n-func getDir(privileged bool, name string, subDir string) (string, error) {\n+// GetDir returns directory where instances file will be stored\n+func GetDir(name string, subDir string) (string, error) {\n \tif err := CheckName(name); err != nil {\n \t\treturn \"\", err\n \t}\n-\tpath, err := getPath(privileged, \"\", subDir)\n+\tpath, err := getPath(\"\", subDir)\n \tif err != nil {\n \t\treturn \"\", err\n \t}\n \treturn filepath.Join(path, name), nil\n }\n \n-// GetDirPrivileged returns directory where instances file will be stored\n-// if instance is run with privileges\n-func GetDirPrivileged(name string, subDir string) (string, error) {\n-\treturn getDir(true, name, subDir)\n-}\n-\n-// GetDirUnprivileged returns directory where instances file will be stored\n-// if instance is run without privileges\n-func GetDirUnprivileged(name string, subDir string) (string, error) {\n-\treturn getDir(false, name, subDir)\n-}\n-\n // Get returns the instance file corresponding to instance name\n func Get(name string, subDir string) (*File, error) {\n \tif err := CheckName(name); err != nil {\n@@ -164,16 +125,16 @@ func Get(name string, subDir string) (*File, error) {\n \n // Add creates an instance file for a named instance in a privileged\n // or unprivileged path\n-func Add(name string, privileged bool, subDir string) (*File, error) {\n+func Add(name string, subDir string) (*File, error) {\n \tif err := CheckName(name); err != nil {\n \t\treturn nil, err\n \t}\n \t_, err := Get(name, subDir)\n \tif err == nil {\n \t\treturn nil, fmt.Errorf(\"instance %s already exists\", name)\n \t}\n-\ti := &File{Name: name, Privileged: privileged}\n-\ti.Path, err = getPath(privileged, \"\", subDir)\n+\ti := &File{Name: name}\n+\ti.Path, err = getPath(\"\", subDir)\n \tif err != nil {\n \t\treturn nil, err\n \t}\n@@ -185,63 +146,41 @@ func Add(name string, privileged bool, subDir string) (*File, error) {\n // List returns instance files matching username and/or name pattern\n func List(username string, name string, subDir string) ([]*File, error) {\n \tlist := make([]*File, 0)\n-\tprivileged := true\n \n-\tfor {\n-\t\tpath, err := getPath(privileged, username, subDir)\n-\t\tif err != nil {\n+\tpath, err := getPath(username, subDir)\n+\tif err != nil {\n+\t\treturn nil, err\n+\t}\n+\tpattern := filepath.Join(path, name, name+\".json\")\n+\tfiles, err := filepath.Glob(pattern)\n+\tif err != nil {\n+\t\treturn nil, err\n+\t}\n+\tfor _, file := range files {\n+\t\tr, err := os.Open(file)\n+\t\tif os.IsNotExist(err) {\n+\t\t\tcontinue\n+\t\t} else if err != nil {\n \t\t\treturn nil, err\n \t\t}\n-\t\tpattern := filepath.Join(path, name, name+\".json\")\n-\t\tfiles, err := filepath.Glob(pattern)\n+\t\tb, err := ioutil.ReadAll(r)\n+\t\tr.Close()\n \t\tif err != nil {\n \t\t\treturn nil, err\n \t\t}\n-\t\tfor _, file := range files {\n-\t\t\tr, err := os.Open(file)\n-\t\t\tif os.IsNotExist(err) {\n-\t\t\t\tcontinue\n-\t\t\t}\n-\t\t\tif err != nil {\n-\t\t\t\treturn nil, err\n-\t\t\t}\n-\t\t\tb, err := ioutil.ReadAll(r)\n-\t\t\tr.Close()\n-\t\t\tif err != nil {\n-\t\t\t\treturn nil, err\n-\t\t\t}\n-\t\t\tf := &File{Path: file}\n-\t\t\tif err := json.Unmarshal(b, f); err != nil {\n-\t\t\t\treturn nil, err\n-\t\t\t}\n-\t\t\tlist = append(list, f)\n-\t\t}\n-\t\tprivileged = !privileged\n-\t\tif privileged {\n-\t\t\tbreak\n+\t\tf := &File{Path: file}\n+\t\tif err := json.Unmarshal(b, f); err != nil {\n+\t\t\treturn nil, err\n \t\t}\n+\t\tlist = append(list, f)\n \t}\n \n \treturn list, nil\n }\n \n-// PrivilegedPath returns if instance file is stored in privileged path or not\n-func (i *File) PrivilegedPath() bool {\n-\treturn strings.HasPrefix(i.Path, privPath)\n-}\n-\n // Delete deletes instance file\n func (i *File) Delete() error {\n-\tpath := filepath.Dir(i.Path)\n-\n-\tnspath := filepath.Join(path, \"ns\")\n-\tif _, err := os.Stat(nspath); err == nil {\n-\t\tif err := syscall.Unmount(nspath, syscall.MNT_DETACH); err != nil {\n-\t\t\tsylog.Errorf(\"can't umount %s: %s\", nspath, err)\n-\t\t}\n-\t}\n-\n-\treturn os.RemoveAll(path)\n+\treturn os.RemoveAll(filepath.Dir(i.Path))\n }\n \n // Update stores instance information in associated instance file\n@@ -259,119 +198,23 @@ func (i *File) Update() error {\n \tif err := os.MkdirAll(path, 0755); err != nil {\n \t\treturn err\n \t}\n-\tif i.PrivilegedPath() {\n-\t\tpw, err := user.GetPwNam(i.User)\n-\t\tif err != nil {\n-\t\t\treturn err\n-\t\t}\n-\t\tif err := os.Chmod(path, 0550); err != nil {\n-\t\t\treturn err\n-\t\t}\n-\t\tif err := os.Chown(path, int(pw.UID), 0); err != nil {\n-\t\t\treturn err\n-\t\t}\n-\t}\n-\tfile, err := os.OpenFile(i.Path, os.O_CREATE|os.O_TRUNC|os.O_WRONLY, 0644)\n+\tfile, err := os.OpenFile(i.Path, os.O_CREATE|os.O_TRUNC|os.O_WRONLY|syscall.O_NOFOLLOW, 0644)\n \tif err != nil {\n \t\treturn err\n \t}\n \tdefer file.Close()\n \n-\tb = append(b, '\\n')\n-\tif n, err := file.Write(b); err != nil || n != len(b) {\n+\tif _, err := file.Write(b); err != nil {\n \t\treturn fmt.Errorf(\"failed to write instance file %s: %s\", i.Path, err)\n \t}\n \n \treturn file.Sync()\n }\n \n-// MountNamespaces binds /proc/<pid>/ns directory into instance folder\n-func (i *File) MountNamespaces() error {\n-\tpath := filepath.Join(filepath.Dir(i.Path), \"ns\")\n-\n-\toldumask := syscall.Umask(0)\n-\tdefer syscall.Umask(oldumask)\n-\n-\tif err := os.Mkdir(path, 0755); err != nil {\n-\t\treturn err\n-\t}\n-\n-\tnspath, err := filepath.EvalSymlinks(path)\n-\tif err != nil {\n-\t\treturn err\n-\t}\n-\n-\tsrc := fmt.Sprintf(\"/proc/%d/ns\", i.Pid)\n-\tif err := syscall.Mount(src, nspath, \"\", syscall.MS_BIND, \"\"); err != nil {\n-\t\treturn fmt.Errorf(\"mounting %s in instance folder failed: %s\", src, err)\n-\t}\n-\n-\treturn nil\n-}\n-\n-// UpdateNamespacesPath updates namespaces path for the provided configuration\n-func (i *File) UpdateNamespacesPath(configNs []specs.LinuxNamespace) error {\n-\tpath := filepath.Join(filepath.Dir(i.Path), \"ns\")\n-\tnspath, err := filepath.EvalSymlinks(path)\n-\tif err != nil {\n-\t\treturn err\n-\t}\n-\tnsBase := filepath.Join(fmt.Sprintf(\"/proc/%d/root\", i.PPid), nspath)\n-\n-\tprocPath := fmt.Sprintf(\"/proc/%d/cmdline\", i.PPid)\n-\n-\tif i.PrivilegedPath() {\n-\t\tvar st syscall.Stat_t\n-\n-\t\tif err := syscall.Stat(procPath, &st); err != nil {\n-\t\t\treturn err\n-\t\t}\n-\t\tif st.Uid != 0 || st.Gid != 0 {\n-\t\t\treturn fmt.Errorf(\"not an instance process\")\n-\t\t}\n-\n-\t\tuid := os.Geteuid()\n-\t\ttaskPath := fmt.Sprintf(\"/proc/%d/task\", i.PPid)\n-\t\tif err := syscall.Stat(taskPath, &st); err != nil {\n-\t\t\treturn err\n-\t\t}\n-\t\tif int(st.Uid) != uid {\n-\t\t\treturn fmt.Errorf(\"you do not own the instance\")\n-\t\t}\n-\t}\n-\n-\tdata, err := ioutil.ReadFile(procPath)\n-\tif err != nil {\n-\t\treturn err\n-\t}\n-\n-\tcmdline := string(data[:len(data)-1])\n-\tprocName, err := ProcName(i.Name, i.User)\n-\tif err != nil {\n-\t\treturn err\n-\t}\n-\tif cmdline != procName {\n-\t\treturn fmt.Errorf(\"no command line match found\")\n-\t}\n-\n-\tfor i, n := range configNs {\n-\t\tns, ok := nsMap[n.Type]\n-\t\tif !ok {\n-\t\t\tconfigNs[i].Path = \"\"\n-\t\t\tcontinue\n-\t\t}\n-\t\tif n.Path != \"\" {\n-\t\t\tconfigNs[i].Path = filepath.Join(nsBase, ns)\n-\t\t}\n-\t}\n-\n-\treturn nil\n-}\n-\n // SetLogFile replaces stdout/stderr streams and redirect content\n // to log file\n func SetLogFile(name string, uid int, subDir string) (*os.File, *os.File, error) {\n-\tpath, err := getPath(false, \"\", subDir)\n+\tpath, err := getPath(\"\", subDir)\n \tif err != nil {\n \t\treturn nil, nil, err\n \t}\n@@ -388,12 +231,12 @@ func SetLogFile(name string, uid int, subDir string) (*os.File, *os.File, error)\n \t\treturn nil, nil, err\n \t}\n \n-\tstderr, err := os.OpenFile(stderrPath, os.O_RDWR|os.O_CREATE|os.O_APPEND, 0644)\n+\tstderr, err := os.OpenFile(stderrPath, os.O_RDWR|os.O_CREATE|os.O_APPEND|syscall.O_NOFOLLOW, 0644)\n \tif err != nil {\n \t\treturn nil, nil, err\n \t}\n \n-\tstdout, err := os.OpenFile(stdoutPath, os.O_RDWR|os.O_CREATE|os.O_APPEND, 0644)\n+\tstdout, err := os.OpenFile(stdoutPath, os.O_RDWR|os.O_CREATE|os.O_APPEND|syscall.O_NOFOLLOW, 0644)\n \tif err != nil {\n \t\treturn nil, nil, err\n \t}")
	patchNew, patchOld := service.HandlePatch(b)
	fmt.Println(patchNew)
	fmt.Println(patchOld)
}
